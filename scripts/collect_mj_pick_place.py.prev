import argparse, json
from pathlib import Path
from datetime import datetime
import numpy as np, cv2
from tqdm import trange
from envs.mj_pick_place_env import MjPickPlaceEnv, MjPickPlaceConfig

def scripted_policy(obs, t, phase_durations):
    s = obs["state"]
    eef = s[0:3]
    gripper = s[3]
    cube = s[4:7]
    tgt = s[7:9]

    # Phases: 0 approach above cube, 1 descend + grasp, 2 move over target (stay high until centered), 3 release
    p0, p1, p2 = phase_durations
    if t < p0:
        phase = 0
    elif t < p0 + p1:
        phase = 1
    elif t < p0 + p1 + p2:
        phase = 2
    else:
        phase = 3

    dx = dy = dz = 0.0
    g = 0.0

    if phase == 0:
        # Move above cube at hover height
        target_z = 0.20
        dx = cube[0] - eef[0]
        dy = cube[1] - eef[1]
        dz = (target_z - eef[2])
        g = 0.0
    elif phase == 1:
        # Descend and grasp
        target_z = cube[2] + 0.01
        dx = cube[0] - eef[0]
        dy = cube[1] - eef[1]
        dz = (target_z - eef[2])
        g = 1.0
    elif phase == 2:
        # Lift and translate above target (stay high until aligned)
        target_z = 0.18
        dx = tgt[0] - eef[0]
        dy = tgt[1] - eef[1]
        dz = (target_z - eef[2])
        g = 1.0
        # If horizontally very close, start gentle vertical correction only
    else:
        # Release while slightly above target (do not drop below success height immediately)
        target_z = 0.10
        dx = tgt[0] - eef[0]
        dy = tgt[1] - eef[1]
        dz = (target_z - eef[2])
        g = 0.0

    vec = np.array([dx, dy, dz], dtype=np.float32)
    # Moderate scaling to avoid overshoot; allow more precise final alignment
    scale = 0.6
    vec = np.tanh(vec * scale)
    return np.concatenate([vec, [g]], axis=0)

def collect(episodes, output, seed):
    cfg = MjPickPlaceConfig(seed=seed)
    env = MjPickPlaceEnv(cfg)
    root = Path(output); root.mkdir(parents=True, exist_ok=True)
    phase_durations = (25, 18, 40)  # adjust to ensure enough alignment time

    for ep in trange(episodes, desc="Collect"):
        obs = env.reset()
        frames = [obs["rgb"]]
        states = [obs["state"]]
        actions = []
        dones = []
        success = False
        for t in range(cfg.max_steps):
            action = scripted_policy(obs, t, phase_durations)
            obs, r, d, info = env.step(action)
            actions.append(action)
            frames.append(obs["rgb"])
            states.append(obs["state"])
            dones.append(d)
            if d:
                success = info["success"]
                break

        ep_dir = root / f"episode_{ep:03d}"
        ep_dir.mkdir(parents=True, exist_ok=True)
        np.savez_compressed(
            ep_dir / "trajectory.npz",
            obs_rgb=np.stack(frames).astype(np.uint8),
            obs_state=np.stack(states).astype(np.float32),
            actions=np.stack(actions).astype(np.float32),
            dones=np.array(dones, dtype=bool),
            success=np.array([success], dtype=bool)
        )
        meta = {
            "episode": ep,
            "success": bool(success),
            "steps": len(actions),
            "seed": seed + ep,
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "instruction": "pick and place the red cube onto the green target"
        }
        with open(ep_dir / "meta.json", "w") as f:
            json.dump(meta, f, indent=2)
        cv2.imwrite(str(ep_dir / "preview.png"), cv2.cvtColor(frames[0], cv2.COLOR_RGB2BGR))

    env.close()

if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("--episodes", type=int, default=10)
    ap.add_argument("--output", type=str, default="data/raw/mj_pick_place_v1")
    ap.add_argument("--seed", type=int, default=42)
    args = ap.parse_args()
    collect(args.episodes, args.output, args.seed)
