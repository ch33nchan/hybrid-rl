import argparse, torch, numpy as np
from envs.mj_pick_place_env import MjPickPlaceEnv, MjPickPlaceConfig
from utils.phase_labeling import label_phase
import torch.nn as nn

class SinusoidalTimeEmbedding(nn.Module):
    def __init__(self, dim): super().__init__(); self.dim=dim
    def forward(self,t):
        device=t.device; half=self.dim//2
        freqs=torch.exp(-torch.arange(half, device=device)*(torch.log(torch.tensor(10000.))/(half-1)))
        args=t.float().unsqueeze(1)*freqs.unsqueeze(0)
        emb=torch.cat([torch.sin(args), torch.cos(args)], dim=-1)
        if self.dim%2: emb=torch.cat([emb, torch.zeros(emb.shape[0],1,device=device)], dim=-1)
        return emb

class CondDiffMLP(nn.Module):
    def __init__(self, seq_dim, state_dim, phase_emb=16, time_dim=128, hidden=512):
        super().__init__()
        self.time=nn.Sequential(SinusoidalTimeEmbedding(time_dim), nn.Linear(time_dim, hidden), nn.SiLU())
        self.phase_emb=nn.Embedding(6, phase_emb)
        self.in_lin=nn.Linear(seq_dim+state_dim+phase_emb, hidden)
        self.block1=nn.Sequential(nn.SiLU(), nn.Linear(hidden, hidden), nn.SiLU())
        self.block2=nn.Sequential(nn.Linear(hidden, hidden), nn.SiLU())
        self.out=nn.Linear(hidden, seq_dim)
    def forward(self,x,state_cond,phase_ids,t):
        temb=self.time(t)
        pemb=self.phase_emb(phase_ids)
        h=self.in_lin(torch.cat([x,state_cond,pemb],dim=-1))
        h=h+temb
        h=self.block1(h)
        h=self.block2(h)
        return self.out(h)

@torch.no_grad()
def ddpm_first_action(model, state_vec, phase_id, betas, act_mean, act_std, horizon):
    device=state_vec.device
    seq_dim=horizon*4
    x=torch.randn(1,seq_dim,device=device)
    alphas=1.0-betas
    alphas_cum=torch.cumprod(alphas,dim=0)
    for t in reversed(range(betas.shape[0])):
        ts=torch.full((1,),t,device=device,dtype=torch.long)
        ph=torch.full((1,),phase_id,device=device,dtype=torch.long)
        eps=model(x,state_vec.unsqueeze(0),ph,ts)
        beta_t=betas[t]
        alpha_t=alphas[t]
        alpha_cum_t=alphas_cum[t]
        coef=(1-alpha_t)/torch.sqrt(1-alpha_cum_t)
        mean=(1/torch.sqrt(alpha_t))*(x - coef*eps)
        if t>0:
            noise=torch.randn_like(x)
            sigma=torch.sqrt(beta_t)
            x=mean+sigma*noise
        else:
            x=mean
    denorm=x.squeeze(0)*act_std.repeat(horizon)+act_mean.repeat(horizon)
    acts=denorm.view(horizon,4)
    return torch.clamp(acts,-1,1).cpu().numpy()

def run(a):
    device=torch.device("mps" if torch.backends.mps.is_available() else "cpu")
    ckpt=torch.load(a.checkpoint,map_location=device)
    model=CondDiffMLP(ckpt["seq_dim"], ckpt["state_dim"], hidden=ckpt.get("hidden_dim",512))
    model.load_state_dict(ckpt["model"])
    model.to(device).eval()
    betas=ckpt.get("betas")
    if betas is None:
        betas=torch.linspace(1e-4,0.02,ckpt["timesteps"])
    betas=betas.to(device)
    act_mean=torch.tensor(ckpt["act_mean"],device=device)
    act_std=torch.tensor(ckpt["act_std"],device=device)
    horizon=ckpt["horizon"]
    env=MjPickPlaceEnv(MjPickPlaceConfig(seed=a.seed))
    successes=0
    for ep in range(a.episodes):
        obs=env.reset(); steps=0; plan=[]
        while True:
            st=obs["state"]
            if len(plan)==0:
                phase_id=label_phase(st)
                state_vec=torch.from_numpy(st).float().to(device)
                seq=ddpm_first_action(model,state_vec,phase_id,betas,act_mean,act_std,horizon)
                plan=seq.tolist()
            act=np.array(plan.pop(0),dtype=np.float32)
            obs,r,d,info=env.step(act)
            steps+=1
            if steps % a.replan_freq==0:
                plan=[]
            if d:
                print(f"Episode {ep} success={info['success']} steps={steps}")
                successes+=int(info["success"])
                break
        if (ep+1)%a.print_every==0:
            print(f"Interim SR: {successes/(ep+1)*100:.2f}%")
    env.close()
    print(f"DDPM Receding-Horizon SR: {successes/a.episodes*100:.2f}%")

if __name__=="__main__":
    ap=argparse.ArgumentParser()
    ap.add_argument("--checkpoint", type=str, default="models/ckpts_diffusion_cond_v2/diffusion_policy_conditioned.pt")
    ap.add_argument("--episodes", type=int, default=20)
    ap.add_argument("--seed", type=int, default=1234)
    ap.add_argument("--replan_freq", type=int, default=3)
    ap.add_argument("--print_every", type=int, default=5)
    a=ap.parse_args()
    run(a)
