import argparse, torch, numpy as np
from envs.mj_pick_place_env import MjPickPlaceEnv, MjPickPlaceConfig
from models.diffusion.unet_policy import SmallUNet1D

def load_model(path, device):
    ckpt = torch.load(path, map_location=device)
    model = SmallUNet1D(seq_dim=ckpt["seq_dim"])
    model.load_state_dict(ckpt["model"])
    model.to(device).eval()
    return model, ckpt

def sample_sequence(model, seq_dim, timesteps, device):
    x = torch.randn(1, seq_dim, device=device)
    for t in reversed(range(timesteps)):
        ts = torch.full((1,), t, device=device, dtype=torch.long)
        eps = model(x, ts)
        x = x - eps * 0.1
    return x.squeeze(0).cpu().numpy()

def run(a):
    device=torch.device("mps" if torch.backends.mps.is_available() else "cpu")
    model, meta = load_model(a.checkpoint, device)
    horizon = meta["horizon"]; adim = 4
    env = MjPickPlaceEnv(MjPickPlaceConfig(seed=a.seed))
    successes=0
    for ep in range(a.episodes):
        obs=env.reset(); steps=0
        buffer=[]
        while True:
            if steps % horizon ==0:
                seq = sample_sequence(model, meta["seq_dim"], meta["timesteps"], device)
                seq_actions = seq.reshape(horizon, adim)
                buffer = [np.clip(a_, -1,1) for a_ in seq_actions]
            act = buffer[min(steps % horizon, len(buffer)-1)]
            obs,r,d,info = env.step(act)
            steps+=1
            if d:
                print(f"Episode {ep} success={info['success']} steps={steps}")
                successes+=int(info["success"])
                break
    env.close()
    print(f"Diffusion Policy SR: {successes/a.episodes*100:.2f}%")

if __name__=="__main__":
    ap=argparse.ArgumentParser()
    ap.add_argument("--checkpoint", type=str, default="models/ckpts_diffusion/diffusion_policy.pt")
    ap.add_argument("--episodes", type=int, default=20)
    ap.add_argument("--seed", type=int, default=42)
    a=ap.parse_args()
    run(a)