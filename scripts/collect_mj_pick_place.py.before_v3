import argparse, json
from datetime import datetime
from pathlib import Path
import numpy as np, cv2
from tqdm import trange
from envs.mj_pick_place_env import MjPickPlaceEnv, MjPickPlaceConfig

def clamp_mag(v, m):
    n = np.linalg.norm(v)
    if n < 1e-8: return v
    return v if n <= m else v * (m / n)

def policy(obs, phase, cfg):
    s = obs["state"]
    eef = s[0:3]
    gripper = s[3]
    cube = s[4:7]
    tgt = s[7:9]

    # Tunables
    hover_z_cube = 0.18
    hover_z_target = 0.18
    descend_z = cube[2] + 0.012
    release_z = 0.11

    dx = dy = dz = 0.0
    g = 0.0

    if phase == 0:  # move above cube
        target = np.array([cube[0], cube[1], hover_z_cube])
        delta = target - eef
        g = 0.0
    elif phase == 1:  # descend & grasp
        target = np.array([cube[0], cube[1], descend_z])
        delta = target - eef
        g = 1.0
    elif phase == 2:  # lift
        target = np.array([cube[0], cube[1], hover_z_cube])
        delta = target - eef
        g = 1.0
    elif phase == 3:  # translate over target at height
        target = np.array([tgt[0], tgt[1], hover_z_target])
        delta = target - eef
        g = 1.0
    elif phase == 4:  # micro-center
        target = np.array([tgt[0], tgt[1], hover_z_target])
        delta = target - eef
        g = 1.0
    else:  # phase 5 release
        target = np.array([tgt[0], tgt[1], release_z])
        delta = target - eef
        g = 0.0

    # Separate horizontal / vertical scaling
    horiz = clamp_mag(delta[:2], 0.04)
    vert = np.clip(delta[2], -0.05, 0.05)
    action_vec = np.array([horiz[0], horiz[1], vert], dtype=np.float32)
    return np.concatenate([action_vec, [g]], axis=0)

def determine_phase(step, obs, cfg):
    # Dynamic gating based on distances
    s = obs["state"]
    eef = s[0:3]
    cube = s[4:7]
    tgt = s[7:9]
    cube_xy_err = np.linalg.norm(eef[:2] - cube[:2])
    tgt_xy_err = np.linalg.norm(eef[:2] - tgt[:2])
    attached = (s[3] > 0.5)

    # Sequence gates
    if not attached:
        # phase 0 -> align above cube
        if cube_xy_err > 0.01 and eef[2] > cube[2] + 0.05:
            return 0
        # phase 1 -> descend & grasp
        if eef[2] > cube[2] + 0.014:
            return 1
        return 2  # if already close
    else:
        # attached: lift then translate
        if eef[2] < 0.165:
            return 2  # continue lift
        if tgt_xy_err > 0.03:
            return 3
        if tgt_xy_err > 0.008:
            return 4  # micro-center
        # close enough -> release phase
        return 5

def collect(episodes, output, seed):
    cfg = MjPickPlaceConfig(seed=seed, debug=False)
    env = MjPickPlaceEnv(cfg)
    out = Path(output); out.mkdir(parents=True, exist_ok=True)

    successes = 0
    for ep in trange(episodes, desc="Collect"):
        obs = env.reset()
        frames = [obs["rgb"]]
        states = [obs["state"]]
        actions = []
        dones = []
        success = False

        for t in range(cfg.max_steps):
            phase = determine_phase(t, obs, cfg)
            a = policy(obs, phase, cfg)
            obs, r, d, info = env.step(a)
            actions.append(a)
            frames.append(obs["rgb"])
            states.append(obs["state"])
            dones.append(d)
            if d:
                success = info["success"]
                break

        if success: successes += 1

        ep_dir = out / f"episode_{ep:03d}"
        ep_dir.mkdir(parents=True, exist_ok=True)
        np.savez_compressed(
            ep_dir / "trajectory.npz",
            obs_rgb=np.stack(frames).astype(np.uint8),
            obs_state=np.stack(states).astype(np.float32),
            actions=np.stack(actions).astype(np.float32),
            dones=np.array(dones, dtype=bool),
            success=np.array([success], dtype=bool)
        )
        meta = {
            "episode": ep,
            "success": bool(success),
            "steps": len(actions),
            "seed": seed + ep,
            "timestamp": datetime.utcnow().isoformat()+"Z",
            "instruction": "pick and place the red cube onto the green target"
        }
        with open(ep_dir / "meta.json","w") as f:
            json.dump(meta, f, indent=2)
        cv2.imwrite(str(ep_dir / "preview.png"),
                    cv2.cvtColor(frames[0], cv2.COLOR_RGB2BGR))

    env.close()
    sr = successes / episodes if episodes else 0
    print(f"Scripted success rate: {sr*100:.2f}% ({successes}/{episodes})")

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--episodes", type=int, default=20)
    ap.add_argument("--output", type=str, default="data/raw/mj_pick_place_v2")
    ap.add_argument("--seed", type=int, default=42)
    args = ap.parse_args()
    collect(args.episodes, args.output, args.seed)
