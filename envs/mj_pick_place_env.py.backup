import numpy as np
import mujoco
from dataclasses import dataclass
from pathlib import Path

@dataclass
class MjPickPlaceConfig:
    xml_path: str = "assets/models/pick_place.xml"
    render_width: int = 128
    render_height: int = 128
    max_steps: int = 120
    action_scale_xy: float = 0.04
    action_scale_z: float = 0.04
    z_min: float = 0.02
    z_max: float = 0.30
    seed: int = 0
    grasp_distance: float = 0.03
    target_radius: float = 0.035
    lift_height_thresh: float = 0.07
    attach_height_offset: float = 0.0
    camera_distance: float = 0.6
    use_offscreen: bool = True

class MjPickPlaceEnv:
    """
    Minimal MuJoCo pick & place.
    Action: [dx, dy, dz, grasp_flag] in [-1,1].
    State: eef_xyz (3) | gripper_closed (1) | cube_xyz (3) | target_xy (2)
    """
    def __init__(self, cfg: MjPickPlaceConfig):
        self.cfg = cfg
        self.rng = np.random.default_rng(cfg.seed)
        xml_full = Path(cfg.xml_path)
        if not xml_full.exists():
            raise FileNotFoundError(f"Missing XML: {xml_full}")
        self.model = mujoco.MjModel.from_xml_path(str(xml_full))
        self.data = mujoco.MjData(self.model)

        # IDs
        self.cube_body_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, "cube_body")
        self.target_body_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, "target_body")
        self.target_site_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_SITE, "target")
        self.eef_body_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, "mocap_eef")
        self.cube_joint_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_JOINT, "cube_free")

        self._constraint_active = False
        self._constraint_id = None
        self.gripper_closed = 0.0
        self.step_count = 0

        # Rendering
        self._cam_initialized = False
        self._offscreen = None

    def reset(self):
        mujoco.mj_resetData(self.model, self.data)
        self.step_count = 0
        self.gripper_closed = 0.0
        self._constraint_active = False
        self._constraint_id = None

        # Randomize cube
        cube_xy = self.rng.uniform(-0.15, 0.15, size=2)
        qadr = self.model.jnt_qposadr[self.cube_joint_id]
        # Free joint qpos: x y z qw qx qy qz
        self.data.qpos[qadr:qadr+7] = np.array([cube_xy[0], cube_xy[1], 0.035, 1, 0, 0, 0], dtype=np.float64)

        # Randomize target
        tgt_xy = self.rng.uniform(-0.15, 0.15, size=2)
        self.model.body_pos[self.target_body_id][:2] = tgt_xy

        # Reset eef
        self._set_mocap_pos(np.array([0.0, 0.0, 0.18], dtype=np.float64))

        mujoco.mj_forward(self.model, self.data)
        for _ in range(5):
            mujoco.mj_step(self.model, self.data)

        return self._get_obs()

    def close(self):
        # Safely dispose renderer
        if self._offscreen is not None:
            if hasattr(self._offscreen, "close"):
                try:
                    self._offscreen.close()
                except Exception:
                    pass
            self._offscreen = None

    def _set_mocap_pos(self, pos):
        mocap_id = self.model.body_mocapid[self.eef_body_id]
        self.data.mocap_pos[mocap_id] = pos

    def _get_cube_pos(self):
        return self.data.xpos[self.cube_body_id].copy()

    def _get_target_xy(self):
        return self.data.site_xpos[self.target_site_id][:2].copy()

    def _get_eef_pos(self):
        return self.data.xpos[self.eef_body_id].copy()

    def _maybe_grasp_weld(self):
        if self._constraint_active:
            return
        if np.linalg.norm(self._get_eef_pos() - self._get_cube_pos()) < self.cfg.grasp_distance:
            self._constraint_id = 1
            self._constraint_active = True

    def _release_weld(self):
        if not self._constraint_active:
            return
        self._constraint_active = False

    def step(self, action: np.ndarray):
        action = np.clip(action, -1, 1)
        dx, dy, dz, g = action
        eef = self._get_eef_pos()
        target_pos = eef + np.array([
            dx * self.cfg.action_scale_xy,
            dy * self.cfg.action_scale_xy,
            dz * self.cfg.action_scale_z
        ])
        target_pos[2] = np.clip(target_pos[2], self.cfg.z_min, self.cfg.z_max)
        self._set_mocap_pos(target_pos)

        new_closed = 1.0 if g > 0 else 0.0
        if new_closed > 0.5 and self.gripper_closed < 0.5:
            self._maybe_grasp_weld()
        elif new_closed < 0.5 and self.gripper_closed > 0.5:
            self._release_weld()
        self.gripper_closed = new_closed

        if self._constraint_active:
            eef_pos = self._get_eef_pos()
            cube_pos = self._get_cube_pos()
            blended = 0.7 * cube_pos + 0.3 * (eef_pos + np.array([0, 0, self.cfg.attach_height_offset]))
            qadr = self.model.jnt_qposadr[self.cube_joint_id]
            self.data.qpos[qadr:qadr+7] = np.array([blended[0], blended[1], blended[2], 1, 0, 0, 0], dtype=np.float64)

        mujoco.mj_step(self.model, self.data)
        self.step_count += 1

        obs = self._get_obs()
        done, success = self._check_done()
        reward = 1.0 if success else 0.0
        return obs, reward, done, {"success": success}

    def _check_done(self):
        cube = self._get_cube_pos()
        tgt = self._get_target_xy()
        dist = np.linalg.norm(cube[:2] - tgt)
        lifted = cube[2] > self.cfg.lift_height_thresh
        success = (dist < self.cfg.target_radius) and lifted
        timeout = self.step_count >= self.cfg.max_steps
        return success or timeout, success

    def _get_obs(self):
        rgb = self._render()
        eef = self._get_eef_pos()
        cube = self._get_cube_pos()
        tgt = self._get_target_xy()
        state = np.concatenate([
            eef[:3].astype(np.float32),
            np.array([self.gripper_closed], dtype=np.float32),
            cube[:3].astype(np.float32),
            tgt.astype(np.float32)
        ])
        return {"rgb": rgb, "state": state}

    def _setup_offscreen(self):
        if not self._cam_initialized:
            self._offscreen = mujoco.Renderer(self.model, self.cfg.render_width, self.cfg.render_height)
            self._cam_initialized = True

    def _render(self):
        self._setup_offscreen()
        self._offscreen.update_scene(self.data)
        return self._offscreen.render()

if __name__ == "__main__":
    env = MjPickPlaceEnv(MjPickPlaceConfig())
    o = env.reset()
    for i in range(30):
        a = np.array([0,0,-0.5,0])
        o,r,d,info = env.step(a)
        if d:
            print("Terminated", info)
            break
    env.close()
