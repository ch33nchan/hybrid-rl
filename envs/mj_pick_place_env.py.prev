import numpy as np
import mujoco
from dataclasses import dataclass
from pathlib import Path

@dataclass
class MjPickPlaceConfig:
    xml_path: str = "assets/models/pick_place.xml"
    render_width: int = 128
    render_height: int = 128
    max_steps: int = 120
    action_scale_xy: float = 0.05
    action_scale_z: float = 0.05
    z_min: float = 0.02
    z_max: float = 0.30
    seed: int = 0
    grasp_distance: float = 0.035
    target_radius: float = 0.045
    lift_height_thresh: float = 0.08
    release_success_height_min: float = 0.045
    attach_height_offset: float = 0.0
    camera_distance: float = 0.6
    use_offscreen: bool = True
    early_terminate_on_success: bool = True

class MjPickPlaceEnv:
    """
    Improved MuJoCo pick & place with crisper grasp and more permissive success:
      Success if:
        (cube_xy within target_radius) AND
        ((cube_z > lift_height_thresh) OR (released && cube_z > release_success_height_min))
    """
    def __init__(self, cfg: MjPickPlaceConfig):
        self.cfg = cfg
        self.rng = np.random.default_rng(cfg.seed)
        xml_full = Path(cfg.xml_path)
        if not xml_full.exists():
            raise FileNotFoundError(f"Missing XML: {xml_full}")
        self.model = mujoco.MjModel.from_xml_path(str(xml_full))
        self.data = mujoco.MjData(self.model)

        self.cube_body_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, "cube_body")
        self.target_body_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, "target_body")
        self.target_site_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_SITE, "target")
        self.eef_body_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, "mocap_eef")
        self.cube_joint_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_JOINT, "cube_free")

        self._attached = False
        self.gripper_closed = 0.0
        self.step_count = 0

        self._cam_initialized = False
        self._offscreen = None

    def reset(self):
        mujoco.mj_resetData(self.model, self.data)
        self.step_count = 0
        self.gripper_closed = 0.0
        self._attached = False

        cube_xy = self.rng.uniform(-0.14, 0.14, size=2)
        qadr = self.model.jnt_qposadr[self.cube_joint_id]
        self.data.qpos[qadr:qadr+7] = np.array([cube_xy[0], cube_xy[1], 0.035, 1, 0, 0, 0], dtype=np.float64)

        tgt_xy = self.rng.uniform(-0.14, 0.14, size=2)
        self.model.body_pos[self.target_body_id][:2] = tgt_xy

        self._set_mocap_pos(np.array([0.0, 0.0, 0.18], dtype=np.float64))
        mujoco.mj_forward(self.model, self.data)
        for _ in range(5):
            mujoco.mj_step(self.model, self.data)
        return self._get_obs()

    def close(self):
        if self._offscreen is not None and hasattr(self._offscreen, "close"):
            try:
                self._offscreen.close()
            except Exception:
                pass
            self._offscreen = None

    def _set_mocap_pos(self, pos):
        mocap_id = self.model.body_mocapid[self.eef_body_id]
        self.data.mocap_pos[mocap_id] = pos

    def _get_cube_pos(self):
        return self.data.xpos[self.cube_body_id].copy()

    def _get_target_xy(self):
        return self.data.site_xpos[self.target_site_id][:2].copy()

    def _get_eef_pos(self):
        return self.data.xpos[self.eef_body_id].copy()

    def _try_attach(self):
        if self._attached:
            return
        if np.linalg.norm(self._get_eef_pos() - self._get_cube_pos()) < self.cfg.grasp_distance:
            self._attached = True

    def _detach(self):
        self._attached = False

    def step(self, action: np.ndarray):
        action = np.clip(action, -1, 1)
        dx, dy, dz, g = action
        eef = self._get_eef_pos()
        target_pos = eef + np.array([
            dx * self.cfg.action_scale_xy,
            dy * self.cfg.action_scale_xy,
            dz * self.cfg.action_scale_z
        ])
        target_pos[2] = np.clip(target_pos[2], self.cfg.z_min, self.cfg.z_max)
        self._set_mocap_pos(target_pos)

        new_closed = 1.0 if g > 0 else 0.0
        if new_closed > 0.5 and self.gripper_closed < 0.5:
            self._try_attach()
        elif new_closed < 0.5 and self.gripper_closed > 0.5:
            self._detach()
        self.gripper_closed = new_closed

        if self._attached:
            eef_pos = self._get_eef_pos()
            qadr = self.model.jnt_qposadr[self.cube_joint_id]
            self.data.qpos[qadr:qadr+7] = np.array([
                eef_pos[0],
                eef_pos[1],
                eef_pos[2] + self.cfg.attach_height_offset,
                1, 0, 0, 0
            ], dtype=np.float64)

        mujoco.mj_step(self.model, self.data)
        self.step_count += 1

        obs = self._get_obs()
        done, success = self._compute_done_success()
        reward = 1.0 if success else 0.0
        if success and self.cfg.early_terminate_on_success:
            done = True
        return obs, reward, done, {"success": success}

    def _compute_done_success(self):
        cube = self._get_cube_pos()
        tgt = self._get_target_xy()
        dist = np.linalg.norm(cube[:2] - tgt)
        lifted = cube[2] > self.cfg.lift_height_thresh
        lifted_release_ok = (cube[2] > self.cfg.release_success_height_min) and (self.gripper_closed < 0.5)
        success = (dist < self.cfg.target_radius) and (lifted or lifted_release_ok)
        timeout = self.step_count >= self.cfg.max_steps
        return (success or timeout), success

    def _get_obs(self):
        rgb = self._render()
        eef = self._get_eef_pos()
        cube = self._get_cube_pos()
        tgt = self._get_target_xy()
        state = np.concatenate([
            eef[:3].astype(np.float32),
            np.array([self.gripper_closed], dtype=np.float32),
            cube[:3].astype(np.float32),
            tgt.astype(np.float32)
        ])
        return {"rgb": rgb, "state": state}

    def _setup_offscreen(self):
        if not self._cam_initialized:
            self._offscreen = mujoco.Renderer(self.model, self.cfg.render_width, self.cfg.render_height)
            self._cam_initialized = True

    def _render(self):
        self._setup_offscreen()
        self._offscreen.update_scene(self.data)
        return self._offscreen.render()

if __name__ == "__main__":
    env = MjPickPlaceEnv(MjPickPlaceConfig())
    o = env.reset()
    for i in range(60):
        a = np.array([0,0,-0.5,0])
        o,r,d,info = env.step(a)
        if d:
            print("Terminated", info)
            break
    env.close()
